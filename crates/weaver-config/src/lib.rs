//! Shared configuration schema for the Weaver CLI and daemon.
//!
//! This crate exposes the [`Config`] structure consumed by `weaver-cli` and
//! `weaverd`. Configuration values are layered using [`ortho_config`], merging
//! configuration files, environment variables, and command-line arguments in
//! increasing precedence. The schema focuses on three core concerns:
//!
//! - Transport sockets used by the daemon and client.
//! - Structured logging defaults.
//! - User-defined capability overrides.
//!
//! ```rust,no_run
//! use weaver_config::Config;
//!
//! # fn try_load() -> ortho_config::OrthoResult<()> {
//! let config = Config::load()?;
//! println!("daemon socket: {}", config.daemon_socket());
//! # Ok(())
//! # }
//! ```
//!
//! [`Config::load`] is generated by the derive macro and honours the discovery
//! strategy documented below. Users can provide an explicit configuration file
//! with `--config-path` or `WEAVER_CONFIG_PATH`.

mod capability;
mod defaults;
mod logging;
mod socket;

use capability::deduplicate_directives;
use ortho_config::OrthoConfig;
use serde::{Deserialize, Serialize};

pub use capability::{
    CapabilityDirective, CapabilityDirectiveParseError, CapabilityMatrix, CapabilityOverride,
    LanguageCapabilities,
};
pub use defaults::{
    DEFAULT_LOG_FILTER, DEFAULT_TCP_PORT, default_log_filter, default_log_format,
    default_socket_endpoint,
};
pub use logging::{LogFormat, LogFormatParseError};
pub use socket::{SocketEndpoint, SocketParseError, SocketPreparationError};

/// Complete configuration merged from defaults, files, environment, and CLI.
#[derive(Debug, Clone, Deserialize, Serialize, OrthoConfig)]
#[serde(default)]
#[ortho_config(
    prefix = "WEAVER",
    discovery(
        app_name = "weaver",
        config_file_name = "config.toml",
        dotfile_name = ".weaver.toml",
        project_file_name = "weaver.toml",
        config_cli_long = "config-path",
        config_cli_visible = true
    )
)]
pub struct Config {
    /// Transport endpoint used by the daemon and CLI.
    #[serde(default = "default_socket_endpoint")]
    #[ortho_config(default = crate::default_socket_endpoint(), cli_long = "daemon-socket")]
    pub daemon_socket: SocketEndpoint,
    /// Tracing filter applied to structured logs.
    #[serde(default = "crate::defaults::default_log_filter_string")]
    #[ortho_config(
        default = String::from(crate::default_log_filter()),
        cli_long = "log-filter"
    )]
    pub log_filter: String,
    /// Output format for structured logs.
    #[serde(default)]
    #[ortho_config(default = crate::default_log_format(), cli_long = "log-format")]
    pub log_format: LogFormat,
    /// Overrides for capability negotiation keyed by language and capability.
    #[serde(default)]
    #[ortho_config(cli_long = "capability-overrides", merge_strategy = "append")]
    pub capability_overrides: Vec<CapabilityDirective>,
}

impl Config {
    /// Loads configuration from defaults, discovery, environment, and CLI.
    #[allow(clippy::missing_panics_doc)]
    pub fn load() -> ortho_config::OrthoResult<Self> {
        let mut config = <Self as OrthoConfig>::load()?;
        config.normalise_capability_overrides();
        Ok(config)
    }

    /// Loads configuration using a custom iterator of CLI arguments.
    pub fn load_from_iter<I, T>(iter: I) -> ortho_config::OrthoResult<Self>
    where
        I: IntoIterator<Item = T>,
        T: Into<std::ffi::OsString> + Clone,
    {
        let mut config = <Self as OrthoConfig>::load_from_iter(iter)?;
        config.normalise_capability_overrides();
        Ok(config)
    }

    /// Accessor for the configured daemon socket.
    #[must_use]
    pub fn daemon_socket(&self) -> &SocketEndpoint {
        &self.daemon_socket
    }

    /// Accessor for the logging filter expression.
    #[must_use]
    pub fn log_filter(&self) -> &str {
        self.log_filter.as_str()
    }

    /// Accessor for the logging format.
    #[must_use]
    pub fn log_format(&self) -> LogFormat {
        self.log_format
    }

    /// Builds a [`CapabilityMatrix`] from the configured directives.
    #[must_use]
    pub fn capability_matrix(&self) -> CapabilityMatrix {
        CapabilityMatrix::from_directives(self.capability_overrides.iter())
    }

    fn normalise_capability_overrides(&mut self) {
        deduplicate_directives(&mut self.capability_overrides);
    }
}

impl Default for Config {
    fn default() -> Self {
        let mut config = Self {
            daemon_socket: default_socket_endpoint(),
            log_filter: crate::defaults::default_log_filter_string(),
            log_format: default_log_format(),
            capability_overrides: Vec::new(),
        };
        config.normalise_capability_overrides();
        config
    }
}
